![img](https://up.sowevo.com/img/20201224124610.jpg)

# Lambda表达式

## 概述

Java中引入了一个新的操作符"**->**",该操作符被称为箭头操作符或者Lambda操作符

箭头操作符将Lambda表达式拆分为2部分

左侧是Lambda的参数列表,

右边是Lambda中需要执行的功能,即Lambda体

依赖于函数式接口,Lambda即对接口的实现

## 函数式接口

- 一个接口(interface),里面只有一个抽象方法,其他什么都没有,就叫做函数式接口
- 重写Object的public方法,不算!!!
- 一般会加上**@FunctionalInterface**,不加也行,不满足上面条件的接口加上这个注解会报错!
- Lambda表达式依赖函数式接口

## 语法

### 1. 无参,无返回值

```java
Runnable runnable = ()-> {
  System.err.println(123);
};
```

### 2. 有一个参数,无返回值

```java
Consumer<String> con = (x)-> {
  System.err.println(x);
};
con.accept("蛤?");
```

### 3. 只有一个参数时,可以省略()

```java
Consumer<String> consumer = x-> {
  System.err.println(x);
};
consumer.accept("床前明月光");
```

### 4. 有两个以上的参数,有返回值,并且Lambda体有多条

```java
Comparator<Integer> com = (x,y)->{
  System.err.println(x);
  System.err.println(y);
  return Integer.compare(x,y);
};
```

### 5. Lambda体中只有一条语句,return和大括号都可以省略不写

```java
Comparator<Integer> com = (x,y)-> Integer.compare(x,y);
```

### 6. 指定数据类型

```java
Comparator<Integer> com = (Integer x,Integer y)-> Integer.compare(x,y);
```

## JDK提供内置的函数式接口

|    类型    |      类       |      抽象方法      |                     描述                     |
| :--------: | :-----------: | :----------------: | :------------------------------------------: |
| 消费型接口 |  Consumer<T>  | void accept(T t);  |        输入某值，无输出。用于消费某值        |
| 供给型接口 |  Supplier<T>  |      T get();      |        无输入，输出某值，用于生产某值        |
| 函数型接口 | Function<T,R> |   R apply(T t);    | 输入某类型值，输出另种类型值，用于类型转化等 |
| 断言型接口 | Predicate<T>  | boolean test(T t); |  输入某个值，输出bool值，用于对某值进行判定  |

具体使用

- 消费型接口

  ```java
  //Consumer<T>:消费型接口
  @Test
  public void test1(){
      happy(10000,(m)->System.out.println("你们哥喜欢大宝剑,每次消费："+m+"元"));
  }
  public void happy(double money, Consumer<Double> consumer){
      consumer.accept(money);
  }
  ```

- 供给型接口

  ```java
  //Supplier<T>:供给型接口
  @Test
  public void test2(){
      List<Integer> numList = getNumList(10, () -> (int) (Math.random() * 100));
      for (Integer num:numList) {
          System.out.println(num);
      }
  }
  //需求：产生指定个数整数,并放入集合中
  public List<Integer> getNumList(int num, Supplier<Integer> supplier){
      List<Integer> list=new ArrayList<>();
      for (int i=0;i<num;i++){
          Integer n = supplier.get();
          list.add(n);
      }
      return list;
  }
  ```

- 函数型接口

  ```java
  //Function<T,R>:函数型接口
  @Test
  public void test3(){
      String newStr = strHandler("\t\t\t 我大北大荒威武  ", (str) -> str.trim());
      System.out.println(newStr);
  
      String subStr = strHandler("我大北大荒威武", (str) -> str.substring(2, 5));
      System.out.println(subStr);
  }
  //需求：用于处理字符串
  public String strHandler(String str, Function<String,String> function){
      return function.apply(str);
  }
  ```

- 断言型接口

  ```java
  //Predicate<T>:断言型接口
  @Test
  public void test4() {
      List<String> list = Arrays.asList("hello", "atguigu", "Lambda", "www", "ok");
      List<String> strList = filterStr(list, (s) -> s.length() > 3);
      for (String str :strList) {
          System.out.println(str);
      }
  }
  
  //需求：将满足条件的字符串,放入集合中
  public List<String> filterStr(List<String> list, Predicate<String> predicate) {
      List<String> strlist = new ArrayList<>();
      for (String str : list) {
          if (predicate.test(str)) {
              strlist.add(str);
          }
      }
      return strlist;
  }
  ```

## 方法引用

### 1. 实例对象名::实例方法名

```java
Consumer c1 = x -> System.err.println(x);
c1.accept("传统Lambda");
Consumer c2 = System.err::println;
c2.accept("实例对象名::实例方法名");
```

### 2. 类名::静态方法名

```java
//传统Lambda
Comparator<Integer> c1 = (x,y)->Integer.compare(x,y);
int compare1 = c1.compare(1, 2);
System.err.println(compare1);
//类名 :: 静态方法名
Comparator<Integer> c2 = Integer::compare;
int compare2 = c2.compare(3, 4);
System.err.println(compare1);
```

### 3. 类名::实例方法名

```java
//传统lambda
BiPredicate<String,String> b1 = (x,y)->x.equalsIgnoreCase(y);
boolean r1 = b1.test("Hello", "hello");
System.err.println(r1);
//类名::实例方法名
BiPredicate<String,String> b2 = String::equalsIgnoreCase;
boolean r2 = b2.test("HeLlO","hello");
System.err.println(r2);
```

# Stream API

## 概述

Stream是Java8中处理集合的关键抽象概念,他可以指定你希望对集合进行的操作,可以执行非常复杂的查找,过滤和映射数据等操作

使用StreamApi对集合进行操作,类似于执行SQL的数据库查询

![image-20201223225723175](https://up.sowevo.com/img/20201223225723.png)

## 特性

- Stream自己不会存储数据,
- Stream不会改变原对象,他们会返回一个持有结果的新流
- Stream操作式延迟执行的,他们会等到需要结果时才执行

## 操作,使用

- 创建流

  ```java
  //List获取流
  List<String> list = new ArrayList<>();
  Stream<String> stream1 = list.stream();
  //数组获取流
  String[] strings = new String[]{};
  Stream<String> stream2 = Arrays.stream(strings);
  //通过Stream创建流
  Stream<Integer> integerStream = Stream.of(1, 2, 3, 4, 5, 6, 7);
  //按照一定的规则无限生成流,使用的时候不加限制就无限生成
  Stream<Integer> iterateStream = Stream.iterate(0, x -> x + 2);
  iterateStream.limit(100).forEach(System.err::println);
  //通过Random创建无限流,支持无限随机int:ints无限随机long:longs等
  IntStream stream2 = new Random().ints()
  ```

- 操作流

  - **中间操作**
    
  ​	中间操作不会消耗流,只是将一个流转换成另外一个流,类似于流水线.
    
    ​	返回值还是Stream流,这些操作会在终端操作进行时才开始运算
    
    - **map**:映射,将流中的数据通过一定的转换映射到另一个流中
    
    ```java
    //求2的n次幂
  Stream<Integer> infiniteStream = Stream.iterate(0, x -> x+1).limit(100);
    infiniteStream.map(x->Math.pow(2,x)).forEach(System.err::println);
      ```
    
    - **filter**按照一定的条件过滤
    
    ```java
    //随机出来一些数,过滤只要偶数
  IntStream limit = new Random().ints().limit(1000);
    limit.filter(x->x%2==0).forEach(System.err::println);
      ```
    
    - **limit**限制流的数量
    
    ```java
    //对无限流进行限制
  IntStream limit = new Random().ints().limit(1000);
    limit.forEach(System.err::println);
      ```
    
    - **shorted**流排序
    
      ```java
    //默认顺序
    IntStream limit = new Random().ints().limit(1000);
    limit.sorted().forEach(System.err::println);
    //指定顺序:Comparator接口
    List<Person> list = Arrays.asList(
      new Person("小花",18,190,10000),
      new Person("小红",32,180,23000),
      new Person("小绿",15,185,18000),
      new Person("小紫",27,165,19000),
    new Person("小黑",23,170,20000),
      new Person("小白",25,155,39000)
  );
    list.stream().sorted((x,y)->Integer.compare(x.getSalary(),y.getSalary())).forEach(System.err::println);
      ```
    
  - **distinct**使用hashCode()和equals()过滤重复数据
    
      ```java
      List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
      numbers.stream().distinct().forEach(System.out::println);
    ```
      
    
  - **终端操作**

    终端操作会消耗流,以产生一个最终结果,终端操作完成后,流就被消耗了,不可再调用相关操作流的方法

    - **forEach**遍历流中的元素

      ```java
      // 获取 Stream 对象
      Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
      // 使用 forEach 输出
      stream.forEach(System.out::println);
      ```

    - **collect**:常用的聚合方法,能将数据进行聚合操作

      ```java
      List<String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl"); 
      List<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());  
      System.out.println("筛选列表: " + filtered); 
      String mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining(", ")); 
      System.out.println("合并字符串: " + mergedString);
      ```

    - **max**:返回流中所有元素的最大值,类似的还有**min**

      ```java
      // 获取 Stream 对象
      Stream<Integer> stream = Stream.of(1, 3, 5, 8);
      // 求 Stream 元素中最大值
      Optional optional = stream.max((x, y) -> x - y);
      ```

    - **count**:统计流中所有元素的数目

      ```java
      // 获取 Stream 对象
      Stream<Integer> stream = Stream.of(1, 3, 5, 8);
      long count = stream.count();
      ```

    - **anyMatch**:判断流中是否存在任意一个元素符合条件,类似的还有**allMatch**,**noneMatch**等

      ```java
      // 获取 Stream 对象
      Stream<String> stream = Stream.of("ab","bc","cd");
      // 判断 stream 中元素是否包含 b 内容
      boolean isMatch = stream.anyMatch(str->str.contains("b"));
      // 输出
      System.out.println(isMatch);
      ```

    - **findFirst**:返回第一个元素,如果流为空,返回空的 Optional 对象,类似的还有**findAny**

      ```java
      // 获取 Stream 对象
      Stream<Integer> stream = Stream.of(1, 3, 5, 8, 10, 13, 15);
      // 通过 filter 过滤,然后获取其中第一个元素
      Optional<Integer> first = stream.filter(x -> x > 3).findFirst();
      ```

## 并行流

- 串行流与并行流

  - **并行流:**就是把一个内容分成多个数据块,并用不同的线程分 别处理每个数据块的流.
  - **串行流:**单线程处理数据

  - **Stream API**可以声明性地通过 parallel() 与sequential() 在串行流与并行流之间切换
  - **Stream API**并行流使用的是forkjoin框架进行并行操作.

- ForkJoin框架

  - ForkJoin框架是Java7提供的一个用于并行执行任务的框架,是一个把大任务分割成若干个小任务,最终汇总每个小任务结果后得到大任务结果的框架.其中Fork就是将大任务拆分成若干个可以并发执行的小任务.Join就是合并所有小任务的执行结果.其执行流程如下图所示：

  ![在这里插入图片描述](https://up.sowevo.com/img/20201224115827.png)

  - ForkJoin的例子

    ```java
    //ForkJoin任务类
    public class ForkJoinCalculate extends RecursiveTask<Long> {
        private Long start;
        private Long end;
        /**任务最小分到多小*/
        private Integer min = 10000;
    
        public ForkJoinCalculate(Long start, Long end, Integer min) {
            this.start = start;
            this.end = end;
            this.min = min;
        }
    
        @Override
        protected Long compute() {
            if (end-start <= min){
                //任务足够细,开始执行
                long sum = 0;
                for (long i = start; i <= end; i++) {
                    sum += i;
                }
                return sum;
            } else {
                //继续拆分任务
                long mid = (start+end)/2;
                ForkJoinCalculate left = new ForkJoinCalculate(start,mid,min);
                ForkJoinCalculate right = new ForkJoinCalculate(mid+1,end,min);
                left.fork();
                right.fork();
                return left.join()+ right.join();
            }
        }
    }
    ==========================
    //调用ForkJoin任务类进行计算
    Instant start = Instant.now();
    ForkJoinPool pool = new ForkJoinPool();
    ForkJoinCalculate calculate = new ForkJoinCalculate(0L,50000000000L,10000);
    Long invoke = pool.invoke(calculate);
    System.err.println(invoke);
    Instant end = Instant.now();
    System.err.println("耗时:"+ Duration.between(start,end).toMillis());//5456  
    ```

  - Stream中使用并行流

    ```java
    //使用.parallel()切换流的执行模式即可.
    Instant start = Instant.now();
    long sum = LongStream.rangeClosed(0, 50000000000L).parallel().sum();
    System.err.println(sum);
    Instant end = Instant.now();
    System.err.println("耗时:"+ Duration.between(start,end).toMillis());
    ```

# 接口的默认方法与静态方法

- 在接口中可以添加使用 default 关键字修饰的非抽象方法,即:默认方法(或扩展方法)

  ```java
  public interface MyInf1 {
      default String getName(){
          return "My name is MyInf1";
      }
  }
  ```

- 接口里可以声明静态方法,并且可以实现

  ```java
  public interface MyInf2 {
      public static void show(){
          System.out.println("接口中的静态方法");
      }
  }
  ```

# 新的时间和日期API

## 背景

在Java 8之前,所有关于时间和日期的API都存在各种使用方面的缺陷,主要有：

1. Java的`java.util.Date`和`java.util.Calendar`类易用性差,不支持时区,而且他们都不是线程安全的；
2. 用于格式化日期的类`DateFormat`被放在`java.text`包中,它是一个抽象类,所以我们需要实例化一个`SimpleDateFormat`对象来处理日期格式化,并且`DateFormat`也是非线程安全,这意味着如果你在多线程程序中调用同一个`DateFormat`对象,会得到意想不到的结果.
3. 对日期的计算方式繁琐,而且容易出错,因为月份是从0开始的,从`Calendar`中获取的月份需要加一才能表示当前月份.

## Java 8日期/时间类

Java 8的日期和时间类包含`LocalDate`,`LocalTime`,`Instant`,`Duration`以及`Period`,这些类都包含在`java.time`包中

1. LocalDate,LocalTime,LocalDateTime

   LocalDate,LocalTime,LocalDateTime 实例是不可变的对象,分别表示使用 ISO-8601 日历系统的日期,时间,日期时间.它们提供简单的日期或时间,并不包含当前的时间信息.与不包含与时区相关的信息.

   - LocalDate:类表示一个具体的日期,但不包含具体时间,也不包含时区信息.

     ```java
     LocalDate localDate = LocalDate.of(2017, 1, 4);     // 初始化一个日期：2017-01-04
     int year = localDate.getYear();                     // 年份：2017
     Month month = localDate.getMonth();                 // 月份：JANUARY
     int dayOfMonth = localDate.getDayOfMonth();         // 月份中的第几天：4
     DayOfWeek dayOfWeek = localDate.getDayOfWeek();     // 一周的第几天：WEDNESDAY
     int length = localDate.lengthOfMonth();             // 月份的天数：31
     boolean leapYear = localDate.isLeapYear();          // 是否为闰年：false
     LocalDate now = LocalDate.now();										//调用静态方法now来获取当前日期
     ```

   - LocalTime:类表示一个具体的时间,但不包含具体日期,也不包含时区信息.

     ```java
     LocalTime localTime = LocalTime.of(17, 23, 52);     // 初始化一个时间：17:23:52
     int hour = localTime.getHour();                     // 时：17
     int minute = localTime.getMinute();                 // 分：23
     int second = localTime.getSecond();                 // 秒：52
     LocalTime now = LocalTime.now();                    //调用静态方法now来获取当前时间
     ```

   - LocalDateTime:LocalDate与LocalTime的结合体

     ```java
     // 初始化一个时间
     LocalDateTime ldt1 = LocalDateTime.of(2017, Month.JANUARY, 4, 17, 23, 52);
     LocalDate localDate = LocalDate.of(2017, Month.JANUARY, 4);
     LocalTime localTime = LocalTime.of(17, 23, 52);
     //合并LocalDate与localTime
     LocalDateTime ldt2 = localDate.atTime(localTime);
     LocalDateTime ldt3 = localTime.atDate(localDate);
     // LocalDateTime 转LocalDate 或 LocalTime
     LocalDate date = ldt1.toLocalDate();
     LocalTime time = ldt1.toLocalTime();
     ```

2. Instant(时间戳:1970年1月1日00:00:00到某个时间之间的毫秒值)

   `Instant`用于表示一个时间戳，它与我们常使用的`System.currentTimeMillis()`有些类似，不过`Instant`可以精确到纳秒(Nano-Second)

   ```java
   Instant ins = Instant.now();                                       //UTC时间戳
   System.err.println(ins);
   ZonedDateTime ins1 = Instant.now().atZone(ZoneId.systemDefault()); //系统时区时间戳
   System.err.println(ins1);
   long l1 = Instant.now().toEpochMilli();                            //转成数字
   System.err.println(l1);
   ```

3. Duration 和 Period :时间段

   - Duration:`Duration`表示一个两个时间的间隔

     ```java
     // 2017-01-05 10:07:00
     LocalDateTime from = LocalDateTime.of(2017, Month.JANUARY, 5, 10, 7, 0);
     // 2017-02-05 10:07:00
     LocalDateTime to = LocalDateTime.of(2017, Month.FEBRUARY, 5, 10, 7, 0);
     // 表示从 2017-01-05 10:07:00 到 2017-02-05 10:07:00 这段时间
     Duration duration = Duration.between(from, to);     
     long days = duration.toDays();              // 这段时间的总天数
     long hours = duration.toHours();            // 这段时间的小时数
     long minutes = duration.toMinutes();        // 这段时间的分钟数
     long seconds = duration.getSeconds();       // 这段时间的秒数
     long milliSeconds = duration.toMillis();    // 这段时间的毫秒数
     long nanoSeconds = duration.toNanos();      // 这段时间的纳秒数
     //通过of()方法创建，该方法接受一个时间段长度，和一个时间单位作为参数
     Duration duration1 = Duration.of(5, ChronoUnit.DAYS);       // 5天
     Duration duration2 = Duration.of(1000, ChronoUnit.MILLIS);  // 1000毫秒
     ```

   - Period:`Period`表示两个日期的间隔

     ```java
     //比如2年3个月6天：
     Period period = Period.of(2, 3, 6);
     // 2017-01-05 到 2017-02-05 这段时间
     Period p1 = Period.between(LocalDate.of(2017, 1, 5),LocalDate.of(2017, 2, 5));
     ```

## 时间日期的操作与格式化

1. 增加和减少日期:使用新的日期/时间类提供的方法

   ```java
   LocalDate date = LocalDate.of(2020, 1, 5);          // 2020-01-05
   
   LocalDate date1 = date.withYear(2021);              // 修改为 2021-01-05
   LocalDate date2 = date.withMonth(2);                // 修改为 2020-02-05
   LocalDate date3 = date.withDayOfMonth(1);           // 修改为 2020-01-01
   
   LocalDate date4 = date.plusYears(1);                // 增加一年 2021-01-05
   LocalDate date5 = date.minusMonths(2);              // 减少两个月 2019-11-05
   LocalDate date6 = date.plus(5, ChronoUnit.DAYS);    // 增加5天 2020-01-10
   ```

2. **TemporalAdjuster**:时间矫正器,对于更复杂的日期操作,可以使用TemporalAdjuster

   - `TemporalAdjusters`类中包含了很多静态方法可以直接使用

   | 方法名                        | 描述                                                        |
   | :---------------------------- | :---------------------------------------------------------- |
   | `dayOfWeekInMonth`            | 返回同一个月中每周的第几天                                  |
   | `firstDayOfMonth`             | 返回当月的第一天                                            |
   | `firstDayOfNextMonth`         | 返回下月的第一天                                            |
   | `firstDayOfNextYear`          | 返回下一年的第一天                                          |
   | `firstDayOfYear`              | 返回本年的第一天                                            |
   | `firstInMonth`                | 返回同一个月中第一个星期几                                  |
   | `lastDayOfMonth`              | 返回当月的最后一天                                          |
   | `lastDayOfNextMonth`          | 返回下月的最后一天                                          |
   | `lastDayOfNextYear`           | 返回下一年的最后一天                                        |
   | `lastDayOfYear`               | 返回本年的最后一天                                          |
   | `lastInMonth`                 | 返回同一个月中最后一个星期几                                |
   | `next / previous`             | 返回后一个/前一个给定的星期几                               |
   | `nextOrSame / previousOrSame` | 返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回 |

   - 示例

   ```java
   LocalDateTime now = LocalDateTime.now();
   LocalDateTime t1 = now.with(TemporalAdjusters.lastDayOfMonth()); //本月最后一天
   LocalDateTime t2 = now.with(TemporalAdjusters.lastDayOfYear());  //本年最后一天
   LocalDateTime t3 = now.with(TemporalAdjusters.firstDayOfNextMonth());//下一月的第一天
   LocalDateTime t4 = now.with(TemporalAdjusters.firstDayOfNextYear());//下一年的第一天
   LocalDateTime t5 = now.with(TemporalAdjusters.firstDayOfYear());//本月的第一天
   LocalDateTime t6 = now.with(TemporalAdjusters.firstDayOfMonth());//本年的第一天
   LocalDateTime t7 = now.with(TemporalAdjusters.next(DayOfWeek.MONDAY));//下一个星期一
   LocalDateTime t8 = now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));//下一个星期日
   LocalDateTime t9 = now.with(TemporalAdjusters.previous(DayOfWeek.MONDAY));//上一个星期一
   LocalDateTime t10 = now.with(TemporalAdjusters.previous(DayOfWeek.SUNDAY));//上一个星期日
   ```

   - 如果上面表格中列出的方法不能满足你的需求,你还可以创建自定义的`TemporalAdjuster`接口的实现,`TemporalAdjuster`也是一个函数式接口,所以我们可以使用Lambda表达式：

     ```java
     //给定一个日期，计算该日期的下一个工作日（不包括星期六和星期天）：
     LocalDate date = LocalDate.of(2017, 1, 5);
     date.with(temporal -> {
         // 当前日期
         DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));
         // 正常情况下，每次增加一天
         int dayToAdd = 1;
         // 如果是星期五，增加三天
         if (dayOfWeek == DayOfWeek.FRIDAY) {
             dayToAdd = 3;
         }
         // 如果是星期六，增加两天
         if (dayOfWeek == DayOfWeek.SATURDAY) {
             dayToAdd = 2;
         }
         return temporal.plus(dayToAdd, ChronoUnit.DAYS);
     });
     ```

     

3. 格式化日期

   新的日期API中提供了一个`DateTimeFormatter`类用于处理日期格式化操作,它被包含在`java.time.format`包中,Java 8的日期类有一个`format()`方法用于将日期格式化为字符串,该方法接收一个`DateTimeFormatter`类型参数：

   ```java
   LocalDateTime dateTime = LocalDateTime.now();
   //BASIC_ISO_DATE:20201225
   String strDate1 = dateTime.format(DateTimeFormatter.BASIC_ISO_DATE);
   //ISO_LOCAL_DATE:2020-12-05
   String strDate2 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);
   //ISO_LOCAL_TIME:14:20:16.998
   String strDate3 = dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME);
   // 2012-12-25
   String strDate4 = dateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));   
   // 今天是：2012年 一月 05日 星期四
   String strDate5 = dateTime.format(DateTimeFormatter.ofPattern("今天是：YYYY年 MMMM DD日 E", Locale.CHINESE)); 
   ```

   也支持由字符串转换成日期格式

   ```java
   String strDate6 = "2020-12-05";
   String strDate7 = "2020-12-05 12:30:05";
   
   LocalDate date = LocalDate.parse(strDate6, DateTimeFormatter.ofPattern("yyyy-MM-dd"));
   LocalDateTime dateTime1 = LocalDateTime.parse(strDate7, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
   ```

4. 时区

   Java 8中的时区操作被很大程度上简化了,新的时区类`java.time.ZoneId`是原有的`java.util.TimeZone`类的替代品.`ZoneId`对象可以通过`ZoneId.of()`方法创建，也可以通过`ZoneId.systemDefault()`获取系统默认时区：

   ```java
   //指定时区
   ZoneId shanghaiZoneId = ZoneId.of("Asia/Shanghai");
   //系统时区
   ZoneId systemZoneId = ZoneId.systemDefault();
   ```

   `of()`方法接收一个“区域/城市”的字符串作为参数,你可以通过`getAvailableZoneIds()`方法获取所有合法的“区域/城市”字符串：

   ```java
   Set<String> zoneIds = ZoneId.getAvailableZoneIds();
   zoneIds.forEach(System.err::println);
   ```

   有了ZoneId,我们可以将`LocalDate`,`LocalTime`或`LocalDateTime`对象转化为`ZonedDateTime`对象：

   ```java
   LocalDateTime localDateTime = LocalDateTime.now();
   ZonedDateTime atZone = localDateTime.atZone(shanghaiZoneId);
   ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);
   ```

# HashMap的变化

- 1.8前:数组+链表

  ![img](https://up.sowevo.com/img/20201222235956)

  - 初始化一个数组,默认容量16,增长因子0.75
  - Put方法
    0. 根据key获得索引位置 i
    1. 如果数组[i]==null,直接新建节点添加,如果table[i]不为空,下一步；
    2. 判断数组[i]的首个元素是否和key一样,如果相同直接覆盖,否则下一步,这里的相同指的是hashCode以及equals,
    3. 遍历数组[i]的链表,如果存在相同,覆盖,如果没有相同,则进行链表的插入
    4. 扩容检测,是否要扩容
       - 数组占用达到了0.75
       - new 新的数组大小X2
       - 老数组的数据重新计算放入新数组

- 1.8:引入了红黑树,整体结构:数组+链表+红黑树

  ![img](https://up.sowevo.com/img/20201223135117.jpeg)

  - 当一次插入前,判断一个链表的长度是否大于8,大于8转换为红黑树
  
- 1.8之后的put流程

  ![img](https://up.sowevo.com/img/20201223002533.png)

# ConcurrentHashMap

- 1.7
  - 采用分段锁解决多线程问题
- 1.8
  - 采用CAS解决多线程问题