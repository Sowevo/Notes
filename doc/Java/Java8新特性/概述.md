# Lambda表达式

## 概述

Java中引入了一个新的操作符"**->**",该操作符被称为箭头操作符或者Lambda操作符

箭头操作符将Lambda表达式拆分为2部分

左侧是Lambda的参数列表,

右边是Lambda中需要执行的功能,即Lambda体

依赖于函数式接口,Lambda即对接口的实现

## 函数式接口

- 一个接口(interface),里面只有一个抽象方法,其他什么都没有,就叫做函数式接口
- 重写Object的public方法,不算!!!
- 一般会加上**@FunctionalInterface**,不加也行,不满足上面条件的接口加上这个注解会报错!
- Lambda表达式依赖函数式接口

## 语法

### 1. 无参,无返回值

```java
Runnable runnable = ()-> {
  System.err.println(123);
};
```

### 2. 有一个参数,无返回值

```java
Consumer<String> con = (x)-> {
  System.err.println(x);
};
con.accept("蛤?");
```

### 3. 只有一个参数时,可以省略()

```java
Consumer<String> consumer = x-> {
  System.err.println(x);
};
consumer.accept("床前明月光");
```

### 4. 有两个以上的参数,有返回值,并且Lambda体有多条

```java
Comparator<Integer> com = (x,y)->{
  System.err.println(x);
  System.err.println(y);
  return Integer.compare(x,y);
};
```

### 5. Lambda体中只有一条语句,return和大括号都可以省略不写

```java
Comparator<Integer> com = (x,y)-> Integer.compare(x,y);
```

### 6. 指定数据类型

```java
Comparator<Integer> com = (Integer x,Integer y)-> Integer.compare(x,y);
```

## JDK提供内置的函数式接口

|    类型    |      类       |      抽象方法      |                     描述                     |
| :--------: | :-----------: | :----------------: | :------------------------------------------: |
| 消费型接口 |  Consumer<T>  | void accept(T t);  |        输入某值，无输出。用于消费某值        |
| 供给型接口 |  Supplier<T>  |      T get();      |        无输入，输出某值，用于生产某值        |
| 函数型接口 | Function<T,R> |   R apply(T t);    | 输入某类型值，输出另种类型值，用于类型转化等 |
| 断言型接口 | Predicate<T>  | boolean test(T t); |  输入某个值，输出bool值，用于对某值进行判定  |

具体使用

- 消费型接口

  ```java
  //Consumer<T>:消费型接口
  @Test
  public void test1(){
      happy(10000,(m)->System.out.println("你们哥喜欢大宝剑，每次消费："+m+"元"));
  }
  public void happy(double money, Consumer<Double> consumer){
      consumer.accept(money);
  }
  ```

- 供给型接口

  ```java
  //Supplier<T>:供给型接口
  @Test
  public void test2(){
      List<Integer> numList = getNumList(10, () -> (int) (Math.random() * 100));
      for (Integer num:numList) {
          System.out.println(num);
      }
  }
  //需求：产生指定个数整数，并放入集合中
  public List<Integer> getNumList(int num, Supplier<Integer> supplier){
      List<Integer> list=new ArrayList<>();
      for (int i=0;i<num;i++){
          Integer n = supplier.get();
          list.add(n);
      }
      return list;
  }
  ```

- 函数型接口

  ```java
  //Function<T,R>:函数型接口
  @Test
  public void test3(){
      String newStr = strHandler("\t\t\t 我大北大荒威武  ", (str) -> str.trim());
      System.out.println(newStr);
  
      String subStr = strHandler("我大北大荒威武", (str) -> str.substring(2, 5));
      System.out.println(subStr);
  }
  //需求：用于处理字符串
  public String strHandler(String str, Function<String,String> function){
      return function.apply(str);
  }
  ```

- 断言型接口

  ```java
  //Predicate<T>:断言型接口
  @Test
  public void test4() {
      List<String> list = Arrays.asList("hello", "atguigu", "Lambda", "www", "ok");
      List<String> strList = filterStr(list, (s) -> s.length() > 3);
      for (String str :strList) {
          System.out.println(str);
      }
  }
  
  //需求：将满足条件的字符串，放入集合中
  public List<String> filterStr(List<String> list, Predicate<String> predicate) {
      List<String> strlist = new ArrayList<>();
      for (String str : list) {
          if (predicate.test(str)) {
              strlist.add(str);
          }
      }
      return strlist;
  }
  ```

## 方法引用

### 1. 实例对象名::实例方法名

```java
Consumer c1 = x -> System.err.println(x);
c1.accept("传统Lambda");
Consumer c2 = System.err::println;
c2.accept("实例对象名::实例方法名");
```

### 2. 类名::静态方法名

```java
//传统Lambda
Comparator<Integer> c1 = (x,y)->Integer.compare(x,y);
int compare1 = c1.compare(1, 2);
System.err.println(compare1);
//类名 :: 静态方法名
Comparator<Integer> c2 = Integer::compare;
int compare2 = c2.compare(3, 4);
System.err.println(compare1);
```

### 3. 类名::实例方法名

```java
//传统lambda
BiPredicate<String,String> b1 = (x,y)->x.equalsIgnoreCase(y);
boolean r1 = b1.test("Hello", "hello");
System.err.println(r1);
//类名::实例方法名
BiPredicate<String,String> b2 = String::equalsIgnoreCase;
boolean r2 = b2.test("HeLlO","hello");
System.err.println(r2);
```

# Stream API

## 概述

Stream是Java8中处理集合的关键抽象概念,他可以指定你希望对集合进行的操作,可以执行非常复杂的查找,过滤和映射数据等操作

使用StreamApi对集合进行操作,类似于执行SQL的数据库查询

![image-20201223225723175](https://up.sowevo.com/img/20201223225723.png)

## 特性

- Stream自己不会存储数据,
- Stream不会改变原对象,他们会返回一个持有结果的新流
- Stream操作式延迟执行的,他们会等到需要结果时才执行

## 操作,使用

- 创建流

  ```java
  //List获取流
  List<String> list = new ArrayList<>();
  Stream<String> stream1 = list.stream();
  //数组获取流
  String[] strings = new String[]{};
  Stream<String> stream2 = Arrays.stream(strings);
  //通过Stream创建流
  Stream<Integer> integerStream = Stream.of(1, 2, 3, 4, 5, 6, 7);
  //按照一定的规则无限生成流,使用的时候不加限制就无限生成
  Stream<Integer> iterateStream = Stream.iterate(0, x -> x + 2);
  iterateStream.limit(100).forEach(System.err::println);
  //通过Random创建无限流,支持无限随机int:ints无限随机long:longs等
  IntStream stream2 = new Random().ints()
  ```

- 操作流

  - **中间操作**
    
  ​	中间操作不会消耗流，只是将一个流转换成另外一个流，类似于流水线。
    
    ​	返回值还是Stream流,这些操作会在终端操作进行时才开始运算
    
    - **map**:映射,将流中的数据通过一定的转换映射到另一个流中
    
    ```java
    //求2的n次幂
  Stream<Integer> infiniteStream = Stream.iterate(0, x -> x+1).limit(100);
    infiniteStream.map(x->Math.pow(2,x)).forEach(System.err::println);
      ```
    
    - **filter**按照一定的条件过滤
    
    ```java
    //随机出来一些数,过滤只要偶数
  IntStream limit = new Random().ints().limit(1000);
    limit.filter(x->x%2==0).forEach(System.err::println);
      ```
    
    - **limit**限制流的数量
    
    ```java
    //对无限流进行限制
  IntStream limit = new Random().ints().limit(1000);
    limit.forEach(System.err::println);
      ```
    
    - **shorted**流排序
    
      ```java
    //默认顺序
    IntStream limit = new Random().ints().limit(1000);
    limit.sorted().forEach(System.err::println);
    //指定顺序:Comparator接口
    List<Person> list = Arrays.asList(
      new Person("小花",18,190,10000),
      new Person("小红",32,180,23000),
      new Person("小绿",15,185,18000),
      new Person("小紫",27,165,19000),
    new Person("小黑",23,170,20000),
      new Person("小白",25,155,39000)
  );
    list.stream().sorted((x,y)->Integer.compare(x.getSalary(),y.getSalary())).forEach(System.err::println);
      ```
    
  - **distinct**使用hashCode()和equals()过滤重复数据
    
      ```java
      List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
      numbers.stream().distinct().forEach(System.out::println);
    ```
      
    
  - **终端操作**

    终端操作会消耗流,以产生一个最终结果,终端操作完成后,流就被消耗了,不可再调用相关操作流的方法

    - **forEach**遍历流中的元素

      ```java
      // 获取 Stream 对象
      Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
      // 使用 forEach 输出
      stream.forEach(System.out::println);
      ```

    - **collect**:常用的聚合方法，能将数据进行聚合操作

      ```java
      List<String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl"); 
      List<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());  
      System.out.println("筛选列表: " + filtered); 
      String mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining(", ")); 
      System.out.println("合并字符串: " + mergedString);
      ```

    - **max**:返回流中所有元素的最大值,类似的还有**min**

      ```java
      // 获取 Stream 对象
      Stream<Integer> stream = Stream.of(1, 3, 5, 8);
      // 求 Stream 元素中最大值
      Optional optional = stream.max((x, y) -> x - y);
      ```

    - **count**:统计流中所有元素的数目

      ```java
      // 获取 Stream 对象
      Stream<Integer> stream = Stream.of(1, 3, 5, 8);
      long count = stream.count();
      ```

    - **anyMatch**:判断流中是否存在任意一个元素符合条件,类似的还有**allMatch**,**noneMatch**等

      ```java
      // 获取 Stream 对象
      Stream<String> stream = Stream.of("ab","bc","cd");
      // 判断 stream 中元素是否包含 b 内容
      boolean isMatch = stream.anyMatch(str->str.contains("b"));
      // 输出
      System.out.println(isMatch);
      ```

    - **findFirst**:返回第一个元素,如果流为空,返回空的 Optional 对象,类似的还有**findAny**

      ```java
      // 获取 Stream 对象
      Stream<Integer> stream = Stream.of(1, 3, 5, 8, 10, 13, 15);
      // 通过 filter 过滤，然后获取其中第一个元素
      Optional<Integer> first = stream.filter(x -> x > 3).findFirst();
      ```

# 接口的默认方法与静态方法

# 新时间日期API

# 其它特性

# HashMap的变化

- 1.8前:数组+链表

  ![img](https://up.sowevo.com/img/20201222235956)

  - 初始化一个数组,默认容量16,增长因子0.75
  - Put方法
    0. 根据key获得索引位置 i
    1. 如果数组[i]==null，直接新建节点添加，如果table[i]不为空,下一步；
    2. 判断数组[i]的首个元素是否和key一样，如果相同直接覆盖,否则下一步，这里的相同指的是hashCode以及equals,
    3. 遍历数组[i]的链表,如果存在相同,覆盖,如果没有相同,则进行链表的插入
    4. 扩容检测,是否要扩容
       - 数组占用达到了0.75
       - new 新的数组大小X2
       - 老数组的数据重新计算放入新数组

- 1.8:引入了红黑树,整体结构:数组+链表+红黑树

  ![img](https://up.sowevo.com/img/20201223135117.jpeg)

  - 当一次插入前,判断一个链表的长度是否大于8,大于8转换为红黑树
  
- 1.8之后的put流程

  ![img](https://up.sowevo.com/img/20201223002533.png)

# ConcurrentHashMap

- 1.7
  - 采用分段锁解决多线程问题
- 1.8
  - 采用CAS解决多线程问题